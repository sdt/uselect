#!/usr/bin/env python2.6

import curses
import itertools
import optparse
import os
import re
import sys

__version__ = '0.1'

#------------------------------------------------------------------------------
class Console:
	def __init__(self):
		# Save the original stdin and stdout, and reopen them to /dev/tty,
		# so that curses will work.
		self.stdin = os.dup(0)
		self.ttyin = open('/dev/tty', 'r')
		os.dup2(self.ttyin.fileno(), 0)

		self.stdout = os.dup(1)
		self.ttyout = open('/dev/tty', 'w')
		os.dup2(self.ttyout.fileno(), 1)

	def __del__(self):
		# Restore the original stdin and stdout.
		os.dup2(self.stdin,  0)
		os.dup2(self.stdout, 1)

#------------------------------------------------------------------------------
class Line:

	def __init__(self, text):
		self.text = text.rstrip('\n\r')
		self.is_selected = False
		self.index_active = None
		self.index_all = -1

#------------------------------------------------------------------------------
class Selector:

	def __init__(self, line_filter, infile):
		self.x = 1
		self.all_lines =  []
		self.active_lines = []
		for text_line in map(lambda t: t.rstrip('\n\r'), infile):
			line = Line(text_line)
			line.index_all = len(self.all_lines)
			self.all_lines.append(line)
			if line_filter(text_line):
				line.index_active = len(self.active_lines)
				self.active_lines.append(line)

	def next_selectable(self, line, dirn):
		index = line.index_active + dirn
		if index not in range(len(self.active_lines)):
			return None
		return self.active_lines[index]

	def lines_selected(self):
		count = 0
		for line in self.active_lines:
			if line.is_selected:
				count += 1
		return count

	def print_lines(self):
		for line in self.active_lines:
			if line.is_selected:
				sys.stdout.write(line.text + '\n')

#------------------------------------------------------------------------------
class UI:

	fg_bg_color = {
		'black':     curses.COLOR_BLACK,
		'white':     curses.COLOR_WHITE,
		'red':       curses.COLOR_RED,
		'yellow':    curses.COLOR_YELLOW,
		'green':     curses.COLOR_GREEN,
		'cyan':      curses.COLOR_CYAN,
		'blue':      curses.COLOR_BLUE,
		'magenta':   curses.COLOR_MAGENTA,

		'base02':    curses.COLOR_BLACK,
		'base2':     curses.COLOR_WHITE,

		'default':   -1,
		'':          -1,
	}

	fg_only_color = {
		'base03':    curses.COLOR_BLACK,
		'base01':    curses.COLOR_GREEN,
		'base00':    curses.COLOR_YELLOW,
		'base0':     curses.COLOR_BLUE,
		'base1':     curses.COLOR_CYAN,
		'base3':     curses.COLOR_WHITE,
		'orange':    curses.COLOR_RED,
		'violet':    curses.COLOR_MAGENTA,
	}

	attr_name = {
		'blink':     curses.A_BLINK,
		'bold':      curses.A_BOLD,
		'dim':       curses.A_DIM,
		'reverse':   curses.A_REVERSE,
		'standout':  curses.A_STANDOUT,
		'underline': curses.A_UNDERLINE,
		'default':   0,
		'':          0,
	}

	colors = {
		'cursor_selected': 'green,base02',
		'cursor_selectable': 'base1,base02',
		'cursor_unselectable': 'base1,base02',
		'nocursor_selected': 'green',
		'nocursor_selectable': 'base0',
		'nocursor_unselectable': 'base01',
		'status': 'base1,base02',
	}

	def __init__(self, selector, message, single_mode):
		self.selector = selector
		self.message  = message
		self.controller = Controller(self, single_mode)

	def _init_curses(self, window):
		self.window = window
		curses.use_default_colors()
		self._update_size()
		self._exit_requested = False
		self._next_color_pair = 1
		self._color_table = {}
		for k,v in UI.colors.iteritems():
			self._color_table[k] = self._parse_color(v)

	def run(self):
		console = Console()
		curses.wrapper(self._run)

	def _run(self, window):
		self._init_curses(window)
		self.cursor_line = self.selector.active_lines[0]
		self.first_line = max(0, self.cursor_line.index_all - self.height + 2)

		need_redraw = True
		while not self._exit_requested:
			if need_redraw:
				self._draw()

			# Update
			need_redraw = self._update()

	def _draw(self):
		self._update_size()
		self.window.erase()

		lines = self.selector.all_lines
		line_count = min(self.height - 1, len(lines) - self.first_line)
		for y in range(0, min(line_count, self.height)):
			line_no = y + self.first_line
			if line_no != self.cursor_line.index_all:
				self._draw_line(y, lines[line_no])
		self._draw_line(self.cursor_line.index_all - self.first_line, self.cursor_line)
		self._draw_status()
		self.window.refresh()

	def _draw_line(self, y, line):
		color = 'cursor_'
		is_cursor = (line == self.cursor_line)
		if not is_cursor:
			color = 'no' + color
		if line.is_selected:
			color += 'selected'
			prefix = '# '
		elif line.index_active is not None:
			color += 'selectable'
			prefix = '. '
		else:
			color += 'unselectable'
			prefix = '  '
		self._set_color(color)
		text = (prefix + line.text)[:self.width];
		if is_cursor:
			text += ' ' * (self.width - len(text))
		self.window.addstr(y, 0, text)

	def _draw_status(self):
		status_left = '%d of %d, %d selected' % ( self.cursor_line.index_active + 1, len(self.selector.active_lines), self.selector.lines_selected() )
		status_right = self.message

		# Can't draw the bottom/right corner of the window
		gap = ' ' * (self.width - len(status_left) - len(status_right) - 1)

		self._set_color('status')
		self.window.addstr(self.height-1, 0, status_left + gap + status_right)

	def _update(self):
		key = self.window.getch()
		if key == curses.ERR:	# resize generates KEY_RESIZE & ERR events
			return False
		if key == curses.KEY_RESIZE:
			return True
		if not self.controller.update(curses.keyname(key)):
			return False

		cursor_index = self.cursor_line.index_all
		if cursor_index < self.first_line:
			self.first_line = cursor_index
		elif cursor_index >= self.first_line + self.height - 1:
			self.first_line = cursor_index - self.height + 2

		return True

	def _exit(self, keep_selection):
		# If there are no selected lines, select this one
		# (sounds wrong, but feels quite natural in practice)
		if keep_selection:
			if next(itertools.ifilter(lambda line: line.is_selected, self.selector.active_lines), None) == None:
				self.cursor_line.is_selected = True
		else:
			self._select_all(lambda line: False)
		self._exit_requested = True

	def _select_all(self, predicate):
		for line in self.selector.active_lines:
			line.is_selected = predicate(line)

	def _set_cursor(self, new_cursor):
		if new_cursor != None:
			self.cursor_line = new_cursor
		return new_cursor

	def _move_cursor(self, dirn):
		new_cursor = self.selector.next_selectable(self.cursor_line, dirn)
		if self._set_cursor(new_cursor) == None:
			self._cursor_to_end(dirn)

	def _page_up_down(self, dirn):
		cursor = self.cursor_line
		start_index = self.cursor_line.index_all

		page_size = self.height - 1
		while dirn * (cursor.index_all - start_index) < page_size:
			new_cursor = self.selector.next_selectable(cursor, dirn)
			if new_cursor == None:
				break
			cursor = new_cursor

		if cursor == self.cursor_line:
			self._cursor_to_end(dirn)
		else:
			self.cursor_line = cursor

	def _cursor_to_end(self, dirn):
		lines = self.selector
		if dirn < 0:
			self._set_cursor(self.selector.active_lines[0])
			self._first_line = 0
		else:
			self._set_cursor(self.selector.active_lines[-1])
			line_count = len(self.selector.all_lines)
			self._first_line = max(0, line_count - self.height + 1)

	def _update_size(self):
		self.height, self.width = self.window.getmaxyx()

	def _parse_color(self, color):
		c = color.split(',')
		fg, bg, attr = (0, -1, 0)
		n = len(c)
		if (n >= 1):
			if c[0] in self.fg_bg_color:
				fg = self.fg_bg_color[c[0]]
			else:
				fg = self.fg_only_color[c[0]]
				attr |= curses.A_BOLD
		if (n >= 2):
			bg = self.fg_bg_color[c[1]]
		if (n >= 3):
			attr |= self.attr_name[c[2]]
		return self._make_color(fg, bg, attr)

	def _make_color(self, fg, bg, attr):
		pair = self._next_color_pair
		self._next_color_pair += 1
		curses.init_pair(pair, fg, bg)
		return attr | curses.color_pair(pair)

	def _set_color(self, name):
		self.window.attrset(self._color_table[name])

#------------------------------------------------------------------------------
class Controller:

	cmd_table_common = {
		'exit':				[ '^J' ],
		'abort':			[ 'KEY_ESC', 'q' ],
		'cursor_dn':		[ 'j', 'KEY_DOWN' ],
		'cursor_up':		[ 'k', 'KEY_UP' ],
		'cursor_pgdn':		[ '^F', '^D', 'KEY_NPAGE' ],
		'cursor_pgup':		[ '^B', '^U', 'KEY_PPAGE' ],
		'cursor_home':		[ 'g', 'KEY_HOME' ],
		'cursor_end':		[ 'G', 'KEY_END' ],
	}

	cmd_table_single = {
		'select_here':		[ ' ' ],
	}

	cmd_table_multi = {
		'toggle_cursor':	[ ' ' ],
		'toggle_all':		[ 't', '^' ],
		'select_all':		[ 'a', '*' ],
		'select_none':		[ 'A', '-' ],
	}

	def __init__(self, ui, single_mode):
		self.ui = ui
		self.key_table = { }
		self.add_commands(Controller.cmd_table_common)
		if single_mode:
			self.add_commands(Controller.cmd_table_single)
		else:
			self.add_commands(Controller.cmd_table_multi)

	def add_commands(self, table):
		for cmd, keys in table.items():
			for key in keys:
				self.key_table[key] = getattr(self, '_cmd_' + cmd)

	def update(self, keyname):
		command = self.key_table.get(keyname)
		if command == None:
			return False
		command()
		return True

	def _cmd_exit(self):			self.ui._exit(True)
	def _cmd_abort(self):			self.ui._exit(False)
	def _cmd_cursor_dn(self):		self.ui._move_cursor(+1)
	def _cmd_cursor_up(self):		self.ui._move_cursor(-1)
	def _cmd_cursor_pgdn(self):		self.ui._page_up_down(+1)
	def _cmd_cursor_pgup(self):		self.ui._page_up_down(-1)
	def _cmd_cursor_home(self):		self.ui._cursor_to_end(-1)
	def _cmd_cursor_end(self):		self.ui._cursor_to_end(+1)
	def _cmd_toggle_cursor(self):	self.ui.cursor_line.is_selected ^= 1
	def _cmd_toggle_all(self): 		self.ui._select_all(lambda line: line.is_selected ^ 1)
	def _cmd_select_all(self):		self.ui._select_all(lambda line: True)
	def _cmd_select_none(self):		self.ui._select_all(lambda line: False)
	def _cmd_select_here(self):		self.ui._select_all(lambda line: line == self.ui.cursor_line)

#------------------------------------------------------------------------------
def make_filter(pattern, invert):
	regex = re.compile(pattern)
	if invert:
		return lambda line: line != '' and regex.search(line) == None
	else:
		return lambda line: line != '' and regex.search(line) != None

def get_opts():
	parser = optparse.OptionParser(
		usage='uselect [-1] [-s regex] [-i] [-m message] [items]',
		version='%prog ' + __version__,
		description=
	"uselect is an interactive line filter intended for use in pipelines.\n"
	"Input lines are read from the command-line or stdin, and displayed\n"
	"to the user. Selected input lines are written to stdout.\n",
		epilog='https://github.com/sdt/uselect',
	)
	parser.add_option('-s', '--select-regex', dest='select', default='.', help='select lines matching regex SELECT')
	parser.add_option('-i', '--invert-selection', dest='invert', action='store_true', help='select lines NOT matching regex SELECT')
	parser.add_option('-m', '--message', dest='message', default='uselect v' + __version__, help='message to display in status bar')
	parser.add_option('-1', '--single',  action='store_true', help='single selection mode')
	return parser.parse_args()

def main():
	opt, args = get_opts()
	line_filter = make_filter(opt.select, opt.invert)
	if args:
		selector = Selector(line_filter, args)
	else:
		selector = Selector(line_filter, sys.stdin)
	if not selector.active_lines:
		print >> sys.stderr, 'No selectable lines'
		sys.exit(1)
	ui = UI(selector, opt.message, opt.single)
	ui.run()
	selector.print_lines()

#------------------------------------------------------------------------------
if __name__ == "__main__":
	try:
		main()
	except KeyboardInterrupt:
		exit(130)
