#!/usr/bin/env python2.7

import argparse
import curses
import itertools
import os
import re
import sys

__version__ = '0.1';

#------------------------------------------------------------------------------
class Console:
	def __init__(self):
		# Save the original stdin and stdout, and reopen them to /dev/tty,
		# so that curses will work.
		self.stdin = os.dup(0)
		self.ttyin = open('/dev/tty', 'r')
		os.dup2(self.ttyin.fileno(), 0)

		self.stdout = os.dup(1)
		self.ttyout = open('/dev/tty', 'w')
		os.dup2(self.ttyout.fileno(), 1)

	def __del__(self):
		# Restore the original stdin and stdout.
		os.dup2(self.stdin,  0)
		os.dup2(self.stdout, 1)

#------------------------------------------------------------------------------
class Line:

	def __init__(self, text, can_select):
		self.text = text.rstrip('\n\r')
		self.can_select = can_select
		self.is_selected = 0

#------------------------------------------------------------------------------
class Selector:

	def __init__(self, line_filter, infile):
		self.x = 1
		self.lines = map(lambda t: Line(t, line_filter(t)), infile)

		line_count = len(self.lines)

		prev_selectable = None
		self.lines_selectable = 0
		for i, line in enumerate(self.lines):
			line.prev_selectable = prev_selectable
			if line.can_select:
				prev_selectable = i
				line.selectable_index = self.lines_selectable
				self.lines_selectable += 1
		self.last_selectable = prev_selectable

		next_selectable = None
		for j, line in enumerate(reversed(self.lines)):
			line.next_selectable = next_selectable
			if line.can_select:
				next_selectable = line_count - j - 1
		self.first_selectable = next_selectable

	def lines_selected(self):
		selected = 0
		for line in self.lines:
			if line.is_selected:
				selected += 1
		return selected

	def next_selectable(self, line, dirn):
		if dirn < 0:
			return self.lines[line].prev_selectable
		else:
			return self.lines[line].next_selectable

	def set_selected(self, is_selected):
		for line in self.lines:
			if line.can_select:
				line.is_selected = is_selected(line)

	def print_lines(self):
		for line in self.lines:
			if line.is_selected:
				sys.stdout.write(line.text + '\n')

#------------------------------------------------------------------------------
class UI:

	fg_bg_color = {
		'black':     curses.COLOR_BLACK,
		'white':     curses.COLOR_WHITE,
		'red':       curses.COLOR_RED,
		'yellow':    curses.COLOR_YELLOW,
		'green':     curses.COLOR_GREEN,
		'cyan':      curses.COLOR_CYAN,
		'blue':      curses.COLOR_BLUE,
		'magenta':   curses.COLOR_MAGENTA,

		'base02':    curses.COLOR_BLACK,
		'base2':     curses.COLOR_WHITE,

		'default':   -1,
		'':          -1,
	}

	fg_only_color = {
		'base03':    curses.COLOR_BLACK,
		'base01':    curses.COLOR_GREEN,
		'base00':    curses.COLOR_YELLOW,
		'base0':     curses.COLOR_BLUE,
		'base1':     curses.COLOR_CYAN,
		'base3':     curses.COLOR_WHITE,
		'orange':    curses.COLOR_RED,
		'violet':    curses.COLOR_MAGENTA,
	}

	attr_name = {
		'blink':     curses.A_BLINK,
		'bold':      curses.A_BOLD,
		'dim':       curses.A_DIM,
		'reverse':   curses.A_REVERSE,
		'standout':  curses.A_STANDOUT,
		'underline': curses.A_UNDERLINE,
		'default':   0,
		'':          0,
	}

	colors = {
		'cursor_selected': 'green,base02',
		'cursor_selectable': 'base1,base02',
		'cursor_unselectable': 'base1,base02',
		'nocursor_selected': 'green',
		'nocursor_selectable': 'base0',
		'nocursor_unselectable': 'base01',
		'status': 'base1,base02',
	}

	def __init__(self, selector, message):
		self.selector = selector
		self.message  = message

	def _init_curses(self, window):
		self.window = window
		curses.cbreak()
		curses.noecho()
		curses.start_color()
		curses.use_default_colors()
		window.keypad(1)
		window.scrollok(0)
		self._update_size()
		self._exit_requested = 0
		self._next_color_pair = 1
		self._color_table = {}
		for k,v in UI.colors.iteritems():
			self._color_table[k] = self._parse_color(v)

	# Is this necessary in the presence of curses.wrapper?
	def _deinit_curses(self):
		curses.nocbreak()
		curses.endwin()

	def run(self):
		console = Console()
		curses.wrapper(self._run)

	def _run(self, window):
		self._init_curses(window)
		self.cursor = self.selector.first_selectable
		self.first_line = max(0, self.cursor - self.height + 2)

		need_redraw = 1
		while not self._exit_requested:
			if need_redraw:
				self._draw()

			# Update
			need_redraw = self._update()

		# Teardown
		self._deinit_curses()

	def _draw(self):
		self._update_size()
		self.window.erase()

		line_count = min(self.height - 1, len(self.selector.lines) - self.first_line)
		for y in range(0, min(line_count, self.height)):
			line_no = y + self.first_line
			if line_no != self.cursor:
				self._draw_line(y, self.selector.lines[line_no], False)
		self._draw_line(self.cursor - self.first_line, self.selector.lines[self.cursor], True)
		self._draw_status();
		self.window.refresh()

	def _draw_line(self, y, line, is_cursor):
		color = 'cursor_'
		if not is_cursor:
			color = 'no' + color
		if line.is_selected:
			color += 'selected'
			prefix = '# '
		elif line.can_select:
			color += 'selectable'
			prefix = '. '
		else:
			color += 'unselectable'
			prefix = '  '
		self._set_color(color)
		text = prefix + line.text
		if is_cursor:
			text += ' ' * (self.width - len(text))
		self.window.addstr(y, 0, text)

	def _draw_status(self):
		cursor_line = self.selector.lines[ self.cursor ];
		status_left = '%d of %d, %d selected' % ( cursor_line.selectable_index + 1, self.selector.lines_selectable, self.selector.lines_selected() )
		status_right = self.message

		# Can't draw the bottom/right corner of the window
		gap = ' ' * (self.width - len(status_left) - len(status_right) - 1)

		self._set_color('status')
		self.window.addstr(self.height-1, 0, status_left + gap + status_right);

	def _update(self):
		key = self.window.getch()
		line = self.selector.lines[self.cursor]

		if key == ord('\n'):
			# If there are no selected lines, select this one
			# (sounds wrong, but feels quite natural in practice)
			if next(itertools.ifilter(lambda line: line.is_selected, self.selector.lines), None) == None:
				line.is_selected = 1
			self._exit_requested = 1
		elif key == ord('q'):
			for line in self.selector.lines:
				line.is_selected = 0
			self._exit_requested = 1
		elif key == ord('k'):
			self._move_cursor(-1)
		elif key == ord('j'):
			self._move_cursor(+1)
		elif key == ord('g'):
			self._cursor_to_end(-1)
		elif key == ord('G'):
			self._cursor_to_end(+1)
		elif key == ord(' '):
			line.is_selected ^= line.can_select
		elif key == ord('t'):
			self.selector.set_selected(lambda line: not line.is_selected)
		elif key == ord('a'):
			self.selector.set_selected(lambda line: True)
		elif key == ord('A'):
			self.selector.set_selected(lambda line: False)
		else:
			return 0

		if self.cursor < self.first_line:
			self.first_line = self.cursor
		elif self.cursor >= self.first_line + self.height - 1:
			self.first_line = self.cursor - self.height + 2

		return 1

	def _set_cursor(self, new_cursor):
		if new_cursor != None:
			self.cursor = new_cursor
		return new_cursor

	def _move_cursor(self, dirn):
		new_cursor = self.selector.next_selectable(self.cursor, dirn)
		if self._set_cursor(new_cursor) == None:
			self._cursor_to_end(dirn)

	def _cursor_to_end(self, dirn):
		slr = self.selector
		line_count = len(slr.lines)
		if dirn < 0:
			self._set_cursor(slr.first_selectable)
			self._first_line = 0
		else:
			self._set_cursor(slr.last_selectable)
			self._first_line = max(0, line_count - self.height + 1)

	def _update_size(self):
		self.height, self.width = self.window.getmaxyx()

	def _parse_color(self, color):
		c = color.split(',')
		fg, bg, attr = (0, -1, 0)
		n = len(c)
		if (n >= 1):
			if c[0] in self.fg_bg_color:
				fg = self.fg_bg_color[c[0]]
			else:
				fg = self.fg_only_color[c[0]]
				attr |= curses.A_BOLD
		if (n >= 2):
			bg = self.fg_bg_color[c[1]]
		if (n >= 3):
			attr |= self.attr_name[c[2]]
		return self._make_color(fg, bg, attr)

	def _make_color(self, fg, bg, attr):
		pair = self._next_color_pair
		self._next_color_pair += 1
		curses.init_pair(pair, fg, bg)
		return attr | curses.color_pair(pair)

	def _set_color(self, name):
		self.window.attrset(self._color_table[name])

#------------------------------------------------------------------------------
def make_filter(pattern, invert):
	regex = re.compile(pattern)
	if invert:
		return lambda line: line != "\n" and regex.search(line) == None
	else:
		return lambda line: line != "\n" and regex.search(line) != None

def get_args():
	parser = argparse.ArgumentParser(
		description='''
			uselect is an interactive line filter intended for use in pipelines.
			Selected input lines are written to stdout.
		''',
		epilog='https://github.com/sdt/uselect',
	)
	parser.add_argument('-s', '--select-regex', dest='select', default='.', help='select lines matching regex SELECT')
	parser.add_argument('-i', '--invert-selection', dest='invert', action='store_true', help='select lines NOT matching regex SELECT')
	parser.add_argument('-m', '--message', dest='message', default='uselect', help='message to display in status bar')
	parser.add_argument('-v', '--version', action='version', version='%(prog)s ' + __version__)
	return parser.parse_args()

def main():
	args = get_args()
	line_filter = make_filter(args.select, args.invert)
	selector = Selector(line_filter, sys.stdin)
	if selector.lines_selectable == 0:
		print >> sys.stderr, 'No selectable lines'
		sys.exit(1)
	ui = UI(selector, args.message)
	ui.run()
	selector.print_lines()

#------------------------------------------------------------------------------
if __name__ == "__main__":
	main()
